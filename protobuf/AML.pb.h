// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AML.proto

#ifndef PROTOBUF_AML_2eproto__INCLUDED
#define PROTOBUF_AML_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace datamodel {
class Attribute;
class AttributeDefaultTypeInternal;
extern AttributeDefaultTypeInternal _Attribute_default_instance_;
class CAEXFile;
class CAEXFileDefaultTypeInternal;
extern CAEXFileDefaultTypeInternal _CAEXFile_default_instance_;
class InstanceHierarchy;
class InstanceHierarchyDefaultTypeInternal;
extern InstanceHierarchyDefaultTypeInternal _InstanceHierarchy_default_instance_;
class InternalElement;
class InternalElementDefaultTypeInternal;
extern InternalElementDefaultTypeInternal _InternalElement_default_instance_;
class RefSemantic;
class RefSemanticDefaultTypeInternal;
extern RefSemanticDefaultTypeInternal _RefSemantic_default_instance_;
class RoleClass;
class RoleClassDefaultTypeInternal;
extern RoleClassDefaultTypeInternal _RoleClass_default_instance_;
class RoleClassLib;
class RoleClassLibDefaultTypeInternal;
extern RoleClassLibDefaultTypeInternal _RoleClassLib_default_instance_;
class SupportedRoleClass;
class SupportedRoleClassDefaultTypeInternal;
extern SupportedRoleClassDefaultTypeInternal _SupportedRoleClass_default_instance_;
class SystemUnitClass;
class SystemUnitClassDefaultTypeInternal;
extern SystemUnitClassDefaultTypeInternal _SystemUnitClass_default_instance_;
class SystemUnitClassLib;
class SystemUnitClassLibDefaultTypeInternal;
extern SystemUnitClassLibDefaultTypeInternal _SystemUnitClassLib_default_instance_;
}  // namespace datamodel

namespace datamodel {

namespace protobuf_AML_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_AML_2eproto

// ===================================================================

class CAEXFile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:datamodel.CAEXFile) */ {
 public:
  CAEXFile();
  virtual ~CAEXFile();

  CAEXFile(const CAEXFile& from);

  inline CAEXFile& operator=(const CAEXFile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CAEXFile(CAEXFile&& from) noexcept
    : CAEXFile() {
    *this = ::std::move(from);
  }

  inline CAEXFile& operator=(CAEXFile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CAEXFile& default_instance();

  static inline const CAEXFile* internal_default_instance() {
    return reinterpret_cast<const CAEXFile*>(
               &_CAEXFile_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(CAEXFile* other);
  friend void swap(CAEXFile& a, CAEXFile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CAEXFile* New() const PROTOBUF_FINAL { return New(NULL); }

  CAEXFile* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CAEXFile& from);
  void MergeFrom(const CAEXFile& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CAEXFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .datamodel.InstanceHierarchy InstanceHierarchy = 5;
  int instancehierarchy_size() const;
  void clear_instancehierarchy();
  static const int kInstanceHierarchyFieldNumber = 5;
  const ::datamodel::InstanceHierarchy& instancehierarchy(int index) const;
  ::datamodel::InstanceHierarchy* mutable_instancehierarchy(int index);
  ::datamodel::InstanceHierarchy* add_instancehierarchy();
  ::google::protobuf::RepeatedPtrField< ::datamodel::InstanceHierarchy >*
      mutable_instancehierarchy();
  const ::google::protobuf::RepeatedPtrField< ::datamodel::InstanceHierarchy >&
      instancehierarchy() const;

  // required string FileName = 1;
  bool has_filename() const;
  void clear_filename();
  static const int kFileNameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // required string SchemaVersion = 2;
  bool has_schemaversion() const;
  void clear_schemaversion();
  static const int kSchemaVersionFieldNumber = 2;
  const ::std::string& schemaversion() const;
  void set_schemaversion(const ::std::string& value);
  #if LANG_CXX11
  void set_schemaversion(::std::string&& value);
  #endif
  void set_schemaversion(const char* value);
  void set_schemaversion(const char* value, size_t size);
  ::std::string* mutable_schemaversion();
  ::std::string* release_schemaversion();
  void set_allocated_schemaversion(::std::string* schemaversion);

  // required string xsi = 3;
  bool has_xsi() const;
  void clear_xsi();
  static const int kXsiFieldNumber = 3;
  const ::std::string& xsi() const;
  void set_xsi(const ::std::string& value);
  #if LANG_CXX11
  void set_xsi(::std::string&& value);
  #endif
  void set_xsi(const char* value);
  void set_xsi(const char* value, size_t size);
  ::std::string* mutable_xsi();
  ::std::string* release_xsi();
  void set_allocated_xsi(::std::string* xsi);

  // required string xmlns = 4;
  bool has_xmlns() const;
  void clear_xmlns();
  static const int kXmlnsFieldNumber = 4;
  const ::std::string& xmlns() const;
  void set_xmlns(const ::std::string& value);
  #if LANG_CXX11
  void set_xmlns(::std::string&& value);
  #endif
  void set_xmlns(const char* value);
  void set_xmlns(const char* value, size_t size);
  ::std::string* mutable_xmlns();
  ::std::string* release_xmlns();
  void set_allocated_xmlns(::std::string* xmlns);

  // @@protoc_insertion_point(class_scope:datamodel.CAEXFile)
 private:
  void set_has_filename();
  void clear_has_filename();
  void set_has_schemaversion();
  void clear_has_schemaversion();
  void set_has_xsi();
  void clear_has_xsi();
  void set_has_xmlns();
  void clear_has_xmlns();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::datamodel::InstanceHierarchy > instancehierarchy_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::google::protobuf::internal::ArenaStringPtr schemaversion_;
  ::google::protobuf::internal::ArenaStringPtr xsi_;
  ::google::protobuf::internal::ArenaStringPtr xmlns_;
  friend struct protobuf_AML_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoleClassLib : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:datamodel.RoleClassLib) */ {
 public:
  RoleClassLib();
  virtual ~RoleClassLib();

  RoleClassLib(const RoleClassLib& from);

  inline RoleClassLib& operator=(const RoleClassLib& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoleClassLib(RoleClassLib&& from) noexcept
    : RoleClassLib() {
    *this = ::std::move(from);
  }

  inline RoleClassLib& operator=(RoleClassLib&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleClassLib& default_instance();

  static inline const RoleClassLib* internal_default_instance() {
    return reinterpret_cast<const RoleClassLib*>(
               &_RoleClassLib_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RoleClassLib* other);
  friend void swap(RoleClassLib& a, RoleClassLib& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoleClassLib* New() const PROTOBUF_FINAL { return New(NULL); }

  RoleClassLib* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoleClassLib& from);
  void MergeFrom(const RoleClassLib& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoleClassLib* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .datamodel.RoleClass RoleClass = 4;
  int roleclass_size() const;
  void clear_roleclass();
  static const int kRoleClassFieldNumber = 4;
  const ::datamodel::RoleClass& roleclass(int index) const;
  ::datamodel::RoleClass* mutable_roleclass(int index);
  ::datamodel::RoleClass* add_roleclass();
  ::google::protobuf::RepeatedPtrField< ::datamodel::RoleClass >*
      mutable_roleclass();
  const ::google::protobuf::RepeatedPtrField< ::datamodel::RoleClass >&
      roleclass() const;

  // required string Name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string Description = 2;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional string Version = 3;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:datamodel.RoleClassLib)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_description();
  void clear_has_description();
  void set_has_version();
  void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::datamodel::RoleClass > roleclass_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  friend struct protobuf_AML_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoleClass : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:datamodel.RoleClass) */ {
 public:
  RoleClass();
  virtual ~RoleClass();

  RoleClass(const RoleClass& from);

  inline RoleClass& operator=(const RoleClass& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoleClass(RoleClass&& from) noexcept
    : RoleClass() {
    *this = ::std::move(from);
  }

  inline RoleClass& operator=(RoleClass&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleClass& default_instance();

  static inline const RoleClass* internal_default_instance() {
    return reinterpret_cast<const RoleClass*>(
               &_RoleClass_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RoleClass* other);
  friend void swap(RoleClass& a, RoleClass& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoleClass* New() const PROTOBUF_FINAL { return New(NULL); }

  RoleClass* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoleClass& from);
  void MergeFrom(const RoleClass& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoleClass* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .datamodel.Attribute Attribute = 4;
  int attribute_size() const;
  void clear_attribute();
  static const int kAttributeFieldNumber = 4;
  const ::datamodel::Attribute& attribute(int index) const;
  ::datamodel::Attribute* mutable_attribute(int index);
  ::datamodel::Attribute* add_attribute();
  ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute >*
      mutable_attribute();
  const ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute >&
      attribute() const;

  // required string Name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string Description = 2;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional string RefBaseClassPath = 3;
  bool has_refbaseclasspath() const;
  void clear_refbaseclasspath();
  static const int kRefBaseClassPathFieldNumber = 3;
  const ::std::string& refbaseclasspath() const;
  void set_refbaseclasspath(const ::std::string& value);
  #if LANG_CXX11
  void set_refbaseclasspath(::std::string&& value);
  #endif
  void set_refbaseclasspath(const char* value);
  void set_refbaseclasspath(const char* value, size_t size);
  ::std::string* mutable_refbaseclasspath();
  ::std::string* release_refbaseclasspath();
  void set_allocated_refbaseclasspath(::std::string* refbaseclasspath);

  // @@protoc_insertion_point(class_scope:datamodel.RoleClass)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_description();
  void clear_has_description();
  void set_has_refbaseclasspath();
  void clear_has_refbaseclasspath();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute > attribute_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr refbaseclasspath_;
  friend struct protobuf_AML_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SystemUnitClassLib : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:datamodel.SystemUnitClassLib) */ {
 public:
  SystemUnitClassLib();
  virtual ~SystemUnitClassLib();

  SystemUnitClassLib(const SystemUnitClassLib& from);

  inline SystemUnitClassLib& operator=(const SystemUnitClassLib& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SystemUnitClassLib(SystemUnitClassLib&& from) noexcept
    : SystemUnitClassLib() {
    *this = ::std::move(from);
  }

  inline SystemUnitClassLib& operator=(SystemUnitClassLib&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemUnitClassLib& default_instance();

  static inline const SystemUnitClassLib* internal_default_instance() {
    return reinterpret_cast<const SystemUnitClassLib*>(
               &_SystemUnitClassLib_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(SystemUnitClassLib* other);
  friend void swap(SystemUnitClassLib& a, SystemUnitClassLib& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SystemUnitClassLib* New() const PROTOBUF_FINAL { return New(NULL); }

  SystemUnitClassLib* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SystemUnitClassLib& from);
  void MergeFrom(const SystemUnitClassLib& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SystemUnitClassLib* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .datamodel.SystemUnitClass SystemUnitClass = 4;
  int systemunitclass_size() const;
  void clear_systemunitclass();
  static const int kSystemUnitClassFieldNumber = 4;
  const ::datamodel::SystemUnitClass& systemunitclass(int index) const;
  ::datamodel::SystemUnitClass* mutable_systemunitclass(int index);
  ::datamodel::SystemUnitClass* add_systemunitclass();
  ::google::protobuf::RepeatedPtrField< ::datamodel::SystemUnitClass >*
      mutable_systemunitclass();
  const ::google::protobuf::RepeatedPtrField< ::datamodel::SystemUnitClass >&
      systemunitclass() const;

  // required string Name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string Version = 2;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:datamodel.SystemUnitClassLib)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_version();
  void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::datamodel::SystemUnitClass > systemunitclass_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  friend struct protobuf_AML_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SystemUnitClass : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:datamodel.SystemUnitClass) */ {
 public:
  SystemUnitClass();
  virtual ~SystemUnitClass();

  SystemUnitClass(const SystemUnitClass& from);

  inline SystemUnitClass& operator=(const SystemUnitClass& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SystemUnitClass(SystemUnitClass&& from) noexcept
    : SystemUnitClass() {
    *this = ::std::move(from);
  }

  inline SystemUnitClass& operator=(SystemUnitClass&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemUnitClass& default_instance();

  static inline const SystemUnitClass* internal_default_instance() {
    return reinterpret_cast<const SystemUnitClass*>(
               &_SystemUnitClass_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(SystemUnitClass* other);
  friend void swap(SystemUnitClass& a, SystemUnitClass& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SystemUnitClass* New() const PROTOBUF_FINAL { return New(NULL); }

  SystemUnitClass* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SystemUnitClass& from);
  void MergeFrom(const SystemUnitClass& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SystemUnitClass* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .datamodel.InternalElement InternalElement = 4;
  int internalelement_size() const;
  void clear_internalelement();
  static const int kInternalElementFieldNumber = 4;
  const ::datamodel::InternalElement& internalelement(int index) const;
  ::datamodel::InternalElement* mutable_internalelement(int index);
  ::datamodel::InternalElement* add_internalelement();
  ::google::protobuf::RepeatedPtrField< ::datamodel::InternalElement >*
      mutable_internalelement();
  const ::google::protobuf::RepeatedPtrField< ::datamodel::InternalElement >&
      internalelement() const;

  // repeated .datamodel.Attribute Attribute = 5;
  int attribute_size() const;
  void clear_attribute();
  static const int kAttributeFieldNumber = 5;
  const ::datamodel::Attribute& attribute(int index) const;
  ::datamodel::Attribute* mutable_attribute(int index);
  ::datamodel::Attribute* add_attribute();
  ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute >*
      mutable_attribute();
  const ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute >&
      attribute() const;

  // required string Name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string RefBaseClassPath = 2;
  bool has_refbaseclasspath() const;
  void clear_refbaseclasspath();
  static const int kRefBaseClassPathFieldNumber = 2;
  const ::std::string& refbaseclasspath() const;
  void set_refbaseclasspath(const ::std::string& value);
  #if LANG_CXX11
  void set_refbaseclasspath(::std::string&& value);
  #endif
  void set_refbaseclasspath(const char* value);
  void set_refbaseclasspath(const char* value, size_t size);
  ::std::string* mutable_refbaseclasspath();
  ::std::string* release_refbaseclasspath();
  void set_allocated_refbaseclasspath(::std::string* refbaseclasspath);

  // optional .datamodel.SupportedRoleClass SupportedRoleClass = 3;
  bool has_supportedroleclass() const;
  void clear_supportedroleclass();
  static const int kSupportedRoleClassFieldNumber = 3;
  const ::datamodel::SupportedRoleClass& supportedroleclass() const;
  ::datamodel::SupportedRoleClass* mutable_supportedroleclass();
  ::datamodel::SupportedRoleClass* release_supportedroleclass();
  void set_allocated_supportedroleclass(::datamodel::SupportedRoleClass* supportedroleclass);

  // @@protoc_insertion_point(class_scope:datamodel.SystemUnitClass)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_refbaseclasspath();
  void clear_has_refbaseclasspath();
  void set_has_supportedroleclass();
  void clear_has_supportedroleclass();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::datamodel::InternalElement > internalelement_;
  ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute > attribute_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr refbaseclasspath_;
  ::datamodel::SupportedRoleClass* supportedroleclass_;
  friend struct protobuf_AML_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InstanceHierarchy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:datamodel.InstanceHierarchy) */ {
 public:
  InstanceHierarchy();
  virtual ~InstanceHierarchy();

  InstanceHierarchy(const InstanceHierarchy& from);

  inline InstanceHierarchy& operator=(const InstanceHierarchy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InstanceHierarchy(InstanceHierarchy&& from) noexcept
    : InstanceHierarchy() {
    *this = ::std::move(from);
  }

  inline InstanceHierarchy& operator=(InstanceHierarchy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceHierarchy& default_instance();

  static inline const InstanceHierarchy* internal_default_instance() {
    return reinterpret_cast<const InstanceHierarchy*>(
               &_InstanceHierarchy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(InstanceHierarchy* other);
  friend void swap(InstanceHierarchy& a, InstanceHierarchy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InstanceHierarchy* New() const PROTOBUF_FINAL { return New(NULL); }

  InstanceHierarchy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InstanceHierarchy& from);
  void MergeFrom(const InstanceHierarchy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InstanceHierarchy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .datamodel.InternalElement InternalElement = 3;
  int internalelement_size() const;
  void clear_internalelement();
  static const int kInternalElementFieldNumber = 3;
  const ::datamodel::InternalElement& internalelement(int index) const;
  ::datamodel::InternalElement* mutable_internalelement(int index);
  ::datamodel::InternalElement* add_internalelement();
  ::google::protobuf::RepeatedPtrField< ::datamodel::InternalElement >*
      mutable_internalelement();
  const ::google::protobuf::RepeatedPtrField< ::datamodel::InternalElement >&
      internalelement() const;

  // required string Name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string Version = 2;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:datamodel.InstanceHierarchy)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_version();
  void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::datamodel::InternalElement > internalelement_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  friend struct protobuf_AML_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InternalElement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:datamodel.InternalElement) */ {
 public:
  InternalElement();
  virtual ~InternalElement();

  InternalElement(const InternalElement& from);

  inline InternalElement& operator=(const InternalElement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InternalElement(InternalElement&& from) noexcept
    : InternalElement() {
    *this = ::std::move(from);
  }

  inline InternalElement& operator=(InternalElement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalElement& default_instance();

  static inline const InternalElement* internal_default_instance() {
    return reinterpret_cast<const InternalElement*>(
               &_InternalElement_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(InternalElement* other);
  friend void swap(InternalElement& a, InternalElement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InternalElement* New() const PROTOBUF_FINAL { return New(NULL); }

  InternalElement* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InternalElement& from);
  void MergeFrom(const InternalElement& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InternalElement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .datamodel.InternalElement InternalElement = 4;
  int internalelement_size() const;
  void clear_internalelement();
  static const int kInternalElementFieldNumber = 4;
  const ::datamodel::InternalElement& internalelement(int index) const;
  ::datamodel::InternalElement* mutable_internalelement(int index);
  ::datamodel::InternalElement* add_internalelement();
  ::google::protobuf::RepeatedPtrField< ::datamodel::InternalElement >*
      mutable_internalelement();
  const ::google::protobuf::RepeatedPtrField< ::datamodel::InternalElement >&
      internalelement() const;

  // repeated .datamodel.Attribute Attribute = 5;
  int attribute_size() const;
  void clear_attribute();
  static const int kAttributeFieldNumber = 5;
  const ::datamodel::Attribute& attribute(int index) const;
  ::datamodel::Attribute* mutable_attribute(int index);
  ::datamodel::Attribute* add_attribute();
  ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute >*
      mutable_attribute();
  const ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute >&
      attribute() const;

  // required string Name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string RefBaseSystemUnitPath = 2;
  bool has_refbasesystemunitpath() const;
  void clear_refbasesystemunitpath();
  static const int kRefBaseSystemUnitPathFieldNumber = 2;
  const ::std::string& refbasesystemunitpath() const;
  void set_refbasesystemunitpath(const ::std::string& value);
  #if LANG_CXX11
  void set_refbasesystemunitpath(::std::string&& value);
  #endif
  void set_refbasesystemunitpath(const char* value);
  void set_refbasesystemunitpath(const char* value, size_t size);
  ::std::string* mutable_refbasesystemunitpath();
  ::std::string* release_refbasesystemunitpath();
  void set_allocated_refbasesystemunitpath(::std::string* refbasesystemunitpath);

  // optional .datamodel.SupportedRoleClass SupportedRoleClass = 3;
  bool has_supportedroleclass() const;
  void clear_supportedroleclass();
  static const int kSupportedRoleClassFieldNumber = 3;
  const ::datamodel::SupportedRoleClass& supportedroleclass() const;
  ::datamodel::SupportedRoleClass* mutable_supportedroleclass();
  ::datamodel::SupportedRoleClass* release_supportedroleclass();
  void set_allocated_supportedroleclass(::datamodel::SupportedRoleClass* supportedroleclass);

  // @@protoc_insertion_point(class_scope:datamodel.InternalElement)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_refbasesystemunitpath();
  void clear_has_refbasesystemunitpath();
  void set_has_supportedroleclass();
  void clear_has_supportedroleclass();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::datamodel::InternalElement > internalelement_;
  ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute > attribute_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr refbasesystemunitpath_;
  ::datamodel::SupportedRoleClass* supportedroleclass_;
  friend struct protobuf_AML_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SupportedRoleClass : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:datamodel.SupportedRoleClass) */ {
 public:
  SupportedRoleClass();
  virtual ~SupportedRoleClass();

  SupportedRoleClass(const SupportedRoleClass& from);

  inline SupportedRoleClass& operator=(const SupportedRoleClass& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SupportedRoleClass(SupportedRoleClass&& from) noexcept
    : SupportedRoleClass() {
    *this = ::std::move(from);
  }

  inline SupportedRoleClass& operator=(SupportedRoleClass&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SupportedRoleClass& default_instance();

  static inline const SupportedRoleClass* internal_default_instance() {
    return reinterpret_cast<const SupportedRoleClass*>(
               &_SupportedRoleClass_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(SupportedRoleClass* other);
  friend void swap(SupportedRoleClass& a, SupportedRoleClass& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SupportedRoleClass* New() const PROTOBUF_FINAL { return New(NULL); }

  SupportedRoleClass* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SupportedRoleClass& from);
  void MergeFrom(const SupportedRoleClass& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SupportedRoleClass* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string RefRoleClassPath = 1;
  bool has_refroleclasspath() const;
  void clear_refroleclasspath();
  static const int kRefRoleClassPathFieldNumber = 1;
  const ::std::string& refroleclasspath() const;
  void set_refroleclasspath(const ::std::string& value);
  #if LANG_CXX11
  void set_refroleclasspath(::std::string&& value);
  #endif
  void set_refroleclasspath(const char* value);
  void set_refroleclasspath(const char* value, size_t size);
  ::std::string* mutable_refroleclasspath();
  ::std::string* release_refroleclasspath();
  void set_allocated_refroleclasspath(::std::string* refroleclasspath);

  // @@protoc_insertion_point(class_scope:datamodel.SupportedRoleClass)
 private:
  void set_has_refroleclasspath();
  void clear_has_refroleclasspath();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr refroleclasspath_;
  friend struct protobuf_AML_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RefSemantic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:datamodel.RefSemantic) */ {
 public:
  RefSemantic();
  virtual ~RefSemantic();

  RefSemantic(const RefSemantic& from);

  inline RefSemantic& operator=(const RefSemantic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RefSemantic(RefSemantic&& from) noexcept
    : RefSemantic() {
    *this = ::std::move(from);
  }

  inline RefSemantic& operator=(RefSemantic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RefSemantic& default_instance();

  static inline const RefSemantic* internal_default_instance() {
    return reinterpret_cast<const RefSemantic*>(
               &_RefSemantic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(RefSemantic* other);
  friend void swap(RefSemantic& a, RefSemantic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RefSemantic* New() const PROTOBUF_FINAL { return New(NULL); }

  RefSemantic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RefSemantic& from);
  void MergeFrom(const RefSemantic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RefSemantic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string CorrespondingAttributePath = 1;
  bool has_correspondingattributepath() const;
  void clear_correspondingattributepath();
  static const int kCorrespondingAttributePathFieldNumber = 1;
  const ::std::string& correspondingattributepath() const;
  void set_correspondingattributepath(const ::std::string& value);
  #if LANG_CXX11
  void set_correspondingattributepath(::std::string&& value);
  #endif
  void set_correspondingattributepath(const char* value);
  void set_correspondingattributepath(const char* value, size_t size);
  ::std::string* mutable_correspondingattributepath();
  ::std::string* release_correspondingattributepath();
  void set_allocated_correspondingattributepath(::std::string* correspondingattributepath);

  // @@protoc_insertion_point(class_scope:datamodel.RefSemantic)
 private:
  void set_has_correspondingattributepath();
  void clear_has_correspondingattributepath();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr correspondingattributepath_;
  friend struct protobuf_AML_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Attribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:datamodel.Attribute) */ {
 public:
  Attribute();
  virtual ~Attribute();

  Attribute(const Attribute& from);

  inline Attribute& operator=(const Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Attribute(Attribute&& from) noexcept
    : Attribute() {
    *this = ::std::move(from);
  }

  inline Attribute& operator=(Attribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Attribute& default_instance();

  static inline const Attribute* internal_default_instance() {
    return reinterpret_cast<const Attribute*>(
               &_Attribute_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Attribute* other);
  friend void swap(Attribute& a, Attribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Attribute* New() const PROTOBUF_FINAL { return New(NULL); }

  Attribute* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Attribute& from);
  void MergeFrom(const Attribute& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Attribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .datamodel.Attribute Attribute = 5;
  int attribute_size() const;
  void clear_attribute();
  static const int kAttributeFieldNumber = 5;
  const ::datamodel::Attribute& attribute(int index) const;
  ::datamodel::Attribute* mutable_attribute(int index);
  ::datamodel::Attribute* add_attribute();
  ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute >*
      mutable_attribute();
  const ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute >&
      attribute() const;

  // required string Name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string AttributeDataType = 2;
  bool has_attributedatatype() const;
  void clear_attributedatatype();
  static const int kAttributeDataTypeFieldNumber = 2;
  const ::std::string& attributedatatype() const;
  void set_attributedatatype(const ::std::string& value);
  #if LANG_CXX11
  void set_attributedatatype(::std::string&& value);
  #endif
  void set_attributedatatype(const char* value);
  void set_attributedatatype(const char* value, size_t size);
  ::std::string* mutable_attributedatatype();
  ::std::string* release_attributedatatype();
  void set_allocated_attributedatatype(::std::string* attributedatatype);

  // optional string Value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional .datamodel.RefSemantic RefSemantic = 4;
  bool has_refsemantic() const;
  void clear_refsemantic();
  static const int kRefSemanticFieldNumber = 4;
  const ::datamodel::RefSemantic& refsemantic() const;
  ::datamodel::RefSemantic* mutable_refsemantic();
  ::datamodel::RefSemantic* release_refsemantic();
  void set_allocated_refsemantic(::datamodel::RefSemantic* refsemantic);

  // @@protoc_insertion_point(class_scope:datamodel.Attribute)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_attributedatatype();
  void clear_has_attributedatatype();
  void set_has_value();
  void clear_has_value();
  void set_has_refsemantic();
  void clear_has_refsemantic();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute > attribute_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr attributedatatype_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::datamodel::RefSemantic* refsemantic_;
  friend struct protobuf_AML_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CAEXFile

// required string FileName = 1;
inline bool CAEXFile::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CAEXFile::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CAEXFile::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CAEXFile::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filename();
}
inline const ::std::string& CAEXFile::filename() const {
  // @@protoc_insertion_point(field_get:datamodel.CAEXFile.FileName)
  return filename_.GetNoArena();
}
inline void CAEXFile::set_filename(const ::std::string& value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.CAEXFile.FileName)
}
#if LANG_CXX11
inline void CAEXFile::set_filename(::std::string&& value) {
  set_has_filename();
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.CAEXFile.FileName)
}
#endif
inline void CAEXFile::set_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.CAEXFile.FileName)
}
inline void CAEXFile::set_filename(const char* value, size_t size) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.CAEXFile.FileName)
}
inline ::std::string* CAEXFile::mutable_filename() {
  set_has_filename();
  // @@protoc_insertion_point(field_mutable:datamodel.CAEXFile.FileName)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CAEXFile::release_filename() {
  // @@protoc_insertion_point(field_release:datamodel.CAEXFile.FileName)
  clear_has_filename();
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CAEXFile::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    set_has_filename();
  } else {
    clear_has_filename();
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:datamodel.CAEXFile.FileName)
}

// required string SchemaVersion = 2;
inline bool CAEXFile::has_schemaversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CAEXFile::set_has_schemaversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CAEXFile::clear_has_schemaversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CAEXFile::clear_schemaversion() {
  schemaversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_schemaversion();
}
inline const ::std::string& CAEXFile::schemaversion() const {
  // @@protoc_insertion_point(field_get:datamodel.CAEXFile.SchemaVersion)
  return schemaversion_.GetNoArena();
}
inline void CAEXFile::set_schemaversion(const ::std::string& value) {
  set_has_schemaversion();
  schemaversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.CAEXFile.SchemaVersion)
}
#if LANG_CXX11
inline void CAEXFile::set_schemaversion(::std::string&& value) {
  set_has_schemaversion();
  schemaversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.CAEXFile.SchemaVersion)
}
#endif
inline void CAEXFile::set_schemaversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_schemaversion();
  schemaversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.CAEXFile.SchemaVersion)
}
inline void CAEXFile::set_schemaversion(const char* value, size_t size) {
  set_has_schemaversion();
  schemaversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.CAEXFile.SchemaVersion)
}
inline ::std::string* CAEXFile::mutable_schemaversion() {
  set_has_schemaversion();
  // @@protoc_insertion_point(field_mutable:datamodel.CAEXFile.SchemaVersion)
  return schemaversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CAEXFile::release_schemaversion() {
  // @@protoc_insertion_point(field_release:datamodel.CAEXFile.SchemaVersion)
  clear_has_schemaversion();
  return schemaversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CAEXFile::set_allocated_schemaversion(::std::string* schemaversion) {
  if (schemaversion != NULL) {
    set_has_schemaversion();
  } else {
    clear_has_schemaversion();
  }
  schemaversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schemaversion);
  // @@protoc_insertion_point(field_set_allocated:datamodel.CAEXFile.SchemaVersion)
}

// required string xsi = 3;
inline bool CAEXFile::has_xsi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CAEXFile::set_has_xsi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CAEXFile::clear_has_xsi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CAEXFile::clear_xsi() {
  xsi_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_xsi();
}
inline const ::std::string& CAEXFile::xsi() const {
  // @@protoc_insertion_point(field_get:datamodel.CAEXFile.xsi)
  return xsi_.GetNoArena();
}
inline void CAEXFile::set_xsi(const ::std::string& value) {
  set_has_xsi();
  xsi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.CAEXFile.xsi)
}
#if LANG_CXX11
inline void CAEXFile::set_xsi(::std::string&& value) {
  set_has_xsi();
  xsi_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.CAEXFile.xsi)
}
#endif
inline void CAEXFile::set_xsi(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_xsi();
  xsi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.CAEXFile.xsi)
}
inline void CAEXFile::set_xsi(const char* value, size_t size) {
  set_has_xsi();
  xsi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.CAEXFile.xsi)
}
inline ::std::string* CAEXFile::mutable_xsi() {
  set_has_xsi();
  // @@protoc_insertion_point(field_mutable:datamodel.CAEXFile.xsi)
  return xsi_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CAEXFile::release_xsi() {
  // @@protoc_insertion_point(field_release:datamodel.CAEXFile.xsi)
  clear_has_xsi();
  return xsi_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CAEXFile::set_allocated_xsi(::std::string* xsi) {
  if (xsi != NULL) {
    set_has_xsi();
  } else {
    clear_has_xsi();
  }
  xsi_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xsi);
  // @@protoc_insertion_point(field_set_allocated:datamodel.CAEXFile.xsi)
}

// required string xmlns = 4;
inline bool CAEXFile::has_xmlns() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CAEXFile::set_has_xmlns() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CAEXFile::clear_has_xmlns() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CAEXFile::clear_xmlns() {
  xmlns_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_xmlns();
}
inline const ::std::string& CAEXFile::xmlns() const {
  // @@protoc_insertion_point(field_get:datamodel.CAEXFile.xmlns)
  return xmlns_.GetNoArena();
}
inline void CAEXFile::set_xmlns(const ::std::string& value) {
  set_has_xmlns();
  xmlns_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.CAEXFile.xmlns)
}
#if LANG_CXX11
inline void CAEXFile::set_xmlns(::std::string&& value) {
  set_has_xmlns();
  xmlns_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.CAEXFile.xmlns)
}
#endif
inline void CAEXFile::set_xmlns(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_xmlns();
  xmlns_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.CAEXFile.xmlns)
}
inline void CAEXFile::set_xmlns(const char* value, size_t size) {
  set_has_xmlns();
  xmlns_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.CAEXFile.xmlns)
}
inline ::std::string* CAEXFile::mutable_xmlns() {
  set_has_xmlns();
  // @@protoc_insertion_point(field_mutable:datamodel.CAEXFile.xmlns)
  return xmlns_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CAEXFile::release_xmlns() {
  // @@protoc_insertion_point(field_release:datamodel.CAEXFile.xmlns)
  clear_has_xmlns();
  return xmlns_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CAEXFile::set_allocated_xmlns(::std::string* xmlns) {
  if (xmlns != NULL) {
    set_has_xmlns();
  } else {
    clear_has_xmlns();
  }
  xmlns_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xmlns);
  // @@protoc_insertion_point(field_set_allocated:datamodel.CAEXFile.xmlns)
}

// repeated .datamodel.InstanceHierarchy InstanceHierarchy = 5;
inline int CAEXFile::instancehierarchy_size() const {
  return instancehierarchy_.size();
}
inline void CAEXFile::clear_instancehierarchy() {
  instancehierarchy_.Clear();
}
inline const ::datamodel::InstanceHierarchy& CAEXFile::instancehierarchy(int index) const {
  // @@protoc_insertion_point(field_get:datamodel.CAEXFile.InstanceHierarchy)
  return instancehierarchy_.Get(index);
}
inline ::datamodel::InstanceHierarchy* CAEXFile::mutable_instancehierarchy(int index) {
  // @@protoc_insertion_point(field_mutable:datamodel.CAEXFile.InstanceHierarchy)
  return instancehierarchy_.Mutable(index);
}
inline ::datamodel::InstanceHierarchy* CAEXFile::add_instancehierarchy() {
  // @@protoc_insertion_point(field_add:datamodel.CAEXFile.InstanceHierarchy)
  return instancehierarchy_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::datamodel::InstanceHierarchy >*
CAEXFile::mutable_instancehierarchy() {
  // @@protoc_insertion_point(field_mutable_list:datamodel.CAEXFile.InstanceHierarchy)
  return &instancehierarchy_;
}
inline const ::google::protobuf::RepeatedPtrField< ::datamodel::InstanceHierarchy >&
CAEXFile::instancehierarchy() const {
  // @@protoc_insertion_point(field_list:datamodel.CAEXFile.InstanceHierarchy)
  return instancehierarchy_;
}

// -------------------------------------------------------------------

// RoleClassLib

// required string Name = 1;
inline bool RoleClassLib::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleClassLib::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleClassLib::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleClassLib::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& RoleClassLib::name() const {
  // @@protoc_insertion_point(field_get:datamodel.RoleClassLib.Name)
  return name_.GetNoArena();
}
inline void RoleClassLib::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.RoleClassLib.Name)
}
#if LANG_CXX11
inline void RoleClassLib::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.RoleClassLib.Name)
}
#endif
inline void RoleClassLib::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.RoleClassLib.Name)
}
inline void RoleClassLib::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.RoleClassLib.Name)
}
inline ::std::string* RoleClassLib::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:datamodel.RoleClassLib.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoleClassLib::release_name() {
  // @@protoc_insertion_point(field_release:datamodel.RoleClassLib.Name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoleClassLib::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:datamodel.RoleClassLib.Name)
}

// optional string Description = 2;
inline bool RoleClassLib::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoleClassLib::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoleClassLib::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoleClassLib::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& RoleClassLib::description() const {
  // @@protoc_insertion_point(field_get:datamodel.RoleClassLib.Description)
  return description_.GetNoArena();
}
inline void RoleClassLib::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.RoleClassLib.Description)
}
#if LANG_CXX11
inline void RoleClassLib::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.RoleClassLib.Description)
}
#endif
inline void RoleClassLib::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.RoleClassLib.Description)
}
inline void RoleClassLib::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.RoleClassLib.Description)
}
inline ::std::string* RoleClassLib::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:datamodel.RoleClassLib.Description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoleClassLib::release_description() {
  // @@protoc_insertion_point(field_release:datamodel.RoleClassLib.Description)
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoleClassLib::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:datamodel.RoleClassLib.Description)
}

// optional string Version = 3;
inline bool RoleClassLib::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoleClassLib::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoleClassLib::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoleClassLib::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& RoleClassLib::version() const {
  // @@protoc_insertion_point(field_get:datamodel.RoleClassLib.Version)
  return version_.GetNoArena();
}
inline void RoleClassLib::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.RoleClassLib.Version)
}
#if LANG_CXX11
inline void RoleClassLib::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.RoleClassLib.Version)
}
#endif
inline void RoleClassLib::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.RoleClassLib.Version)
}
inline void RoleClassLib::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.RoleClassLib.Version)
}
inline ::std::string* RoleClassLib::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:datamodel.RoleClassLib.Version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoleClassLib::release_version() {
  // @@protoc_insertion_point(field_release:datamodel.RoleClassLib.Version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoleClassLib::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:datamodel.RoleClassLib.Version)
}

// repeated .datamodel.RoleClass RoleClass = 4;
inline int RoleClassLib::roleclass_size() const {
  return roleclass_.size();
}
inline void RoleClassLib::clear_roleclass() {
  roleclass_.Clear();
}
inline const ::datamodel::RoleClass& RoleClassLib::roleclass(int index) const {
  // @@protoc_insertion_point(field_get:datamodel.RoleClassLib.RoleClass)
  return roleclass_.Get(index);
}
inline ::datamodel::RoleClass* RoleClassLib::mutable_roleclass(int index) {
  // @@protoc_insertion_point(field_mutable:datamodel.RoleClassLib.RoleClass)
  return roleclass_.Mutable(index);
}
inline ::datamodel::RoleClass* RoleClassLib::add_roleclass() {
  // @@protoc_insertion_point(field_add:datamodel.RoleClassLib.RoleClass)
  return roleclass_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::datamodel::RoleClass >*
RoleClassLib::mutable_roleclass() {
  // @@protoc_insertion_point(field_mutable_list:datamodel.RoleClassLib.RoleClass)
  return &roleclass_;
}
inline const ::google::protobuf::RepeatedPtrField< ::datamodel::RoleClass >&
RoleClassLib::roleclass() const {
  // @@protoc_insertion_point(field_list:datamodel.RoleClassLib.RoleClass)
  return roleclass_;
}

// -------------------------------------------------------------------

// RoleClass

// required string Name = 1;
inline bool RoleClass::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleClass::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleClass::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleClass::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& RoleClass::name() const {
  // @@protoc_insertion_point(field_get:datamodel.RoleClass.Name)
  return name_.GetNoArena();
}
inline void RoleClass::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.RoleClass.Name)
}
#if LANG_CXX11
inline void RoleClass::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.RoleClass.Name)
}
#endif
inline void RoleClass::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.RoleClass.Name)
}
inline void RoleClass::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.RoleClass.Name)
}
inline ::std::string* RoleClass::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:datamodel.RoleClass.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoleClass::release_name() {
  // @@protoc_insertion_point(field_release:datamodel.RoleClass.Name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoleClass::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:datamodel.RoleClass.Name)
}

// optional string Description = 2;
inline bool RoleClass::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoleClass::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoleClass::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoleClass::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& RoleClass::description() const {
  // @@protoc_insertion_point(field_get:datamodel.RoleClass.Description)
  return description_.GetNoArena();
}
inline void RoleClass::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.RoleClass.Description)
}
#if LANG_CXX11
inline void RoleClass::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.RoleClass.Description)
}
#endif
inline void RoleClass::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.RoleClass.Description)
}
inline void RoleClass::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.RoleClass.Description)
}
inline ::std::string* RoleClass::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:datamodel.RoleClass.Description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoleClass::release_description() {
  // @@protoc_insertion_point(field_release:datamodel.RoleClass.Description)
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoleClass::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:datamodel.RoleClass.Description)
}

// optional string RefBaseClassPath = 3;
inline bool RoleClass::has_refbaseclasspath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoleClass::set_has_refbaseclasspath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoleClass::clear_has_refbaseclasspath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoleClass::clear_refbaseclasspath() {
  refbaseclasspath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_refbaseclasspath();
}
inline const ::std::string& RoleClass::refbaseclasspath() const {
  // @@protoc_insertion_point(field_get:datamodel.RoleClass.RefBaseClassPath)
  return refbaseclasspath_.GetNoArena();
}
inline void RoleClass::set_refbaseclasspath(const ::std::string& value) {
  set_has_refbaseclasspath();
  refbaseclasspath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.RoleClass.RefBaseClassPath)
}
#if LANG_CXX11
inline void RoleClass::set_refbaseclasspath(::std::string&& value) {
  set_has_refbaseclasspath();
  refbaseclasspath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.RoleClass.RefBaseClassPath)
}
#endif
inline void RoleClass::set_refbaseclasspath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_refbaseclasspath();
  refbaseclasspath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.RoleClass.RefBaseClassPath)
}
inline void RoleClass::set_refbaseclasspath(const char* value, size_t size) {
  set_has_refbaseclasspath();
  refbaseclasspath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.RoleClass.RefBaseClassPath)
}
inline ::std::string* RoleClass::mutable_refbaseclasspath() {
  set_has_refbaseclasspath();
  // @@protoc_insertion_point(field_mutable:datamodel.RoleClass.RefBaseClassPath)
  return refbaseclasspath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoleClass::release_refbaseclasspath() {
  // @@protoc_insertion_point(field_release:datamodel.RoleClass.RefBaseClassPath)
  clear_has_refbaseclasspath();
  return refbaseclasspath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoleClass::set_allocated_refbaseclasspath(::std::string* refbaseclasspath) {
  if (refbaseclasspath != NULL) {
    set_has_refbaseclasspath();
  } else {
    clear_has_refbaseclasspath();
  }
  refbaseclasspath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), refbaseclasspath);
  // @@protoc_insertion_point(field_set_allocated:datamodel.RoleClass.RefBaseClassPath)
}

// repeated .datamodel.Attribute Attribute = 4;
inline int RoleClass::attribute_size() const {
  return attribute_.size();
}
inline void RoleClass::clear_attribute() {
  attribute_.Clear();
}
inline const ::datamodel::Attribute& RoleClass::attribute(int index) const {
  // @@protoc_insertion_point(field_get:datamodel.RoleClass.Attribute)
  return attribute_.Get(index);
}
inline ::datamodel::Attribute* RoleClass::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:datamodel.RoleClass.Attribute)
  return attribute_.Mutable(index);
}
inline ::datamodel::Attribute* RoleClass::add_attribute() {
  // @@protoc_insertion_point(field_add:datamodel.RoleClass.Attribute)
  return attribute_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute >*
RoleClass::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:datamodel.RoleClass.Attribute)
  return &attribute_;
}
inline const ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute >&
RoleClass::attribute() const {
  // @@protoc_insertion_point(field_list:datamodel.RoleClass.Attribute)
  return attribute_;
}

// -------------------------------------------------------------------

// SystemUnitClassLib

// required string Name = 1;
inline bool SystemUnitClassLib::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemUnitClassLib::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemUnitClassLib::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemUnitClassLib::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& SystemUnitClassLib::name() const {
  // @@protoc_insertion_point(field_get:datamodel.SystemUnitClassLib.Name)
  return name_.GetNoArena();
}
inline void SystemUnitClassLib::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.SystemUnitClassLib.Name)
}
#if LANG_CXX11
inline void SystemUnitClassLib::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.SystemUnitClassLib.Name)
}
#endif
inline void SystemUnitClassLib::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.SystemUnitClassLib.Name)
}
inline void SystemUnitClassLib::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.SystemUnitClassLib.Name)
}
inline ::std::string* SystemUnitClassLib::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:datamodel.SystemUnitClassLib.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemUnitClassLib::release_name() {
  // @@protoc_insertion_point(field_release:datamodel.SystemUnitClassLib.Name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemUnitClassLib::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:datamodel.SystemUnitClassLib.Name)
}

// optional string Version = 2;
inline bool SystemUnitClassLib::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemUnitClassLib::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemUnitClassLib::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemUnitClassLib::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& SystemUnitClassLib::version() const {
  // @@protoc_insertion_point(field_get:datamodel.SystemUnitClassLib.Version)
  return version_.GetNoArena();
}
inline void SystemUnitClassLib::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.SystemUnitClassLib.Version)
}
#if LANG_CXX11
inline void SystemUnitClassLib::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.SystemUnitClassLib.Version)
}
#endif
inline void SystemUnitClassLib::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.SystemUnitClassLib.Version)
}
inline void SystemUnitClassLib::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.SystemUnitClassLib.Version)
}
inline ::std::string* SystemUnitClassLib::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:datamodel.SystemUnitClassLib.Version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemUnitClassLib::release_version() {
  // @@protoc_insertion_point(field_release:datamodel.SystemUnitClassLib.Version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemUnitClassLib::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:datamodel.SystemUnitClassLib.Version)
}

// repeated .datamodel.SystemUnitClass SystemUnitClass = 4;
inline int SystemUnitClassLib::systemunitclass_size() const {
  return systemunitclass_.size();
}
inline void SystemUnitClassLib::clear_systemunitclass() {
  systemunitclass_.Clear();
}
inline const ::datamodel::SystemUnitClass& SystemUnitClassLib::systemunitclass(int index) const {
  // @@protoc_insertion_point(field_get:datamodel.SystemUnitClassLib.SystemUnitClass)
  return systemunitclass_.Get(index);
}
inline ::datamodel::SystemUnitClass* SystemUnitClassLib::mutable_systemunitclass(int index) {
  // @@protoc_insertion_point(field_mutable:datamodel.SystemUnitClassLib.SystemUnitClass)
  return systemunitclass_.Mutable(index);
}
inline ::datamodel::SystemUnitClass* SystemUnitClassLib::add_systemunitclass() {
  // @@protoc_insertion_point(field_add:datamodel.SystemUnitClassLib.SystemUnitClass)
  return systemunitclass_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::datamodel::SystemUnitClass >*
SystemUnitClassLib::mutable_systemunitclass() {
  // @@protoc_insertion_point(field_mutable_list:datamodel.SystemUnitClassLib.SystemUnitClass)
  return &systemunitclass_;
}
inline const ::google::protobuf::RepeatedPtrField< ::datamodel::SystemUnitClass >&
SystemUnitClassLib::systemunitclass() const {
  // @@protoc_insertion_point(field_list:datamodel.SystemUnitClassLib.SystemUnitClass)
  return systemunitclass_;
}

// -------------------------------------------------------------------

// SystemUnitClass

// required string Name = 1;
inline bool SystemUnitClass::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemUnitClass::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemUnitClass::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemUnitClass::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& SystemUnitClass::name() const {
  // @@protoc_insertion_point(field_get:datamodel.SystemUnitClass.Name)
  return name_.GetNoArena();
}
inline void SystemUnitClass::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.SystemUnitClass.Name)
}
#if LANG_CXX11
inline void SystemUnitClass::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.SystemUnitClass.Name)
}
#endif
inline void SystemUnitClass::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.SystemUnitClass.Name)
}
inline void SystemUnitClass::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.SystemUnitClass.Name)
}
inline ::std::string* SystemUnitClass::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:datamodel.SystemUnitClass.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemUnitClass::release_name() {
  // @@protoc_insertion_point(field_release:datamodel.SystemUnitClass.Name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemUnitClass::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:datamodel.SystemUnitClass.Name)
}

// optional string RefBaseClassPath = 2;
inline bool SystemUnitClass::has_refbaseclasspath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemUnitClass::set_has_refbaseclasspath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemUnitClass::clear_has_refbaseclasspath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemUnitClass::clear_refbaseclasspath() {
  refbaseclasspath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_refbaseclasspath();
}
inline const ::std::string& SystemUnitClass::refbaseclasspath() const {
  // @@protoc_insertion_point(field_get:datamodel.SystemUnitClass.RefBaseClassPath)
  return refbaseclasspath_.GetNoArena();
}
inline void SystemUnitClass::set_refbaseclasspath(const ::std::string& value) {
  set_has_refbaseclasspath();
  refbaseclasspath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.SystemUnitClass.RefBaseClassPath)
}
#if LANG_CXX11
inline void SystemUnitClass::set_refbaseclasspath(::std::string&& value) {
  set_has_refbaseclasspath();
  refbaseclasspath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.SystemUnitClass.RefBaseClassPath)
}
#endif
inline void SystemUnitClass::set_refbaseclasspath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_refbaseclasspath();
  refbaseclasspath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.SystemUnitClass.RefBaseClassPath)
}
inline void SystemUnitClass::set_refbaseclasspath(const char* value, size_t size) {
  set_has_refbaseclasspath();
  refbaseclasspath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.SystemUnitClass.RefBaseClassPath)
}
inline ::std::string* SystemUnitClass::mutable_refbaseclasspath() {
  set_has_refbaseclasspath();
  // @@protoc_insertion_point(field_mutable:datamodel.SystemUnitClass.RefBaseClassPath)
  return refbaseclasspath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SystemUnitClass::release_refbaseclasspath() {
  // @@protoc_insertion_point(field_release:datamodel.SystemUnitClass.RefBaseClassPath)
  clear_has_refbaseclasspath();
  return refbaseclasspath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SystemUnitClass::set_allocated_refbaseclasspath(::std::string* refbaseclasspath) {
  if (refbaseclasspath != NULL) {
    set_has_refbaseclasspath();
  } else {
    clear_has_refbaseclasspath();
  }
  refbaseclasspath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), refbaseclasspath);
  // @@protoc_insertion_point(field_set_allocated:datamodel.SystemUnitClass.RefBaseClassPath)
}

// optional .datamodel.SupportedRoleClass SupportedRoleClass = 3;
inline bool SystemUnitClass::has_supportedroleclass() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemUnitClass::set_has_supportedroleclass() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemUnitClass::clear_has_supportedroleclass() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemUnitClass::clear_supportedroleclass() {
  if (supportedroleclass_ != NULL) supportedroleclass_->::datamodel::SupportedRoleClass::Clear();
  clear_has_supportedroleclass();
}
inline const ::datamodel::SupportedRoleClass& SystemUnitClass::supportedroleclass() const {
  const ::datamodel::SupportedRoleClass* p = supportedroleclass_;
  // @@protoc_insertion_point(field_get:datamodel.SystemUnitClass.SupportedRoleClass)
  return p != NULL ? *p : *reinterpret_cast<const ::datamodel::SupportedRoleClass*>(
      &::datamodel::_SupportedRoleClass_default_instance_);
}
inline ::datamodel::SupportedRoleClass* SystemUnitClass::mutable_supportedroleclass() {
  set_has_supportedroleclass();
  if (supportedroleclass_ == NULL) {
    supportedroleclass_ = new ::datamodel::SupportedRoleClass;
  }
  // @@protoc_insertion_point(field_mutable:datamodel.SystemUnitClass.SupportedRoleClass)
  return supportedroleclass_;
}
inline ::datamodel::SupportedRoleClass* SystemUnitClass::release_supportedroleclass() {
  // @@protoc_insertion_point(field_release:datamodel.SystemUnitClass.SupportedRoleClass)
  clear_has_supportedroleclass();
  ::datamodel::SupportedRoleClass* temp = supportedroleclass_;
  supportedroleclass_ = NULL;
  return temp;
}
inline void SystemUnitClass::set_allocated_supportedroleclass(::datamodel::SupportedRoleClass* supportedroleclass) {
  delete supportedroleclass_;
  supportedroleclass_ = supportedroleclass;
  if (supportedroleclass) {
    set_has_supportedroleclass();
  } else {
    clear_has_supportedroleclass();
  }
  // @@protoc_insertion_point(field_set_allocated:datamodel.SystemUnitClass.SupportedRoleClass)
}

// repeated .datamodel.InternalElement InternalElement = 4;
inline int SystemUnitClass::internalelement_size() const {
  return internalelement_.size();
}
inline void SystemUnitClass::clear_internalelement() {
  internalelement_.Clear();
}
inline const ::datamodel::InternalElement& SystemUnitClass::internalelement(int index) const {
  // @@protoc_insertion_point(field_get:datamodel.SystemUnitClass.InternalElement)
  return internalelement_.Get(index);
}
inline ::datamodel::InternalElement* SystemUnitClass::mutable_internalelement(int index) {
  // @@protoc_insertion_point(field_mutable:datamodel.SystemUnitClass.InternalElement)
  return internalelement_.Mutable(index);
}
inline ::datamodel::InternalElement* SystemUnitClass::add_internalelement() {
  // @@protoc_insertion_point(field_add:datamodel.SystemUnitClass.InternalElement)
  return internalelement_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::datamodel::InternalElement >*
SystemUnitClass::mutable_internalelement() {
  // @@protoc_insertion_point(field_mutable_list:datamodel.SystemUnitClass.InternalElement)
  return &internalelement_;
}
inline const ::google::protobuf::RepeatedPtrField< ::datamodel::InternalElement >&
SystemUnitClass::internalelement() const {
  // @@protoc_insertion_point(field_list:datamodel.SystemUnitClass.InternalElement)
  return internalelement_;
}

// repeated .datamodel.Attribute Attribute = 5;
inline int SystemUnitClass::attribute_size() const {
  return attribute_.size();
}
inline void SystemUnitClass::clear_attribute() {
  attribute_.Clear();
}
inline const ::datamodel::Attribute& SystemUnitClass::attribute(int index) const {
  // @@protoc_insertion_point(field_get:datamodel.SystemUnitClass.Attribute)
  return attribute_.Get(index);
}
inline ::datamodel::Attribute* SystemUnitClass::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:datamodel.SystemUnitClass.Attribute)
  return attribute_.Mutable(index);
}
inline ::datamodel::Attribute* SystemUnitClass::add_attribute() {
  // @@protoc_insertion_point(field_add:datamodel.SystemUnitClass.Attribute)
  return attribute_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute >*
SystemUnitClass::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:datamodel.SystemUnitClass.Attribute)
  return &attribute_;
}
inline const ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute >&
SystemUnitClass::attribute() const {
  // @@protoc_insertion_point(field_list:datamodel.SystemUnitClass.Attribute)
  return attribute_;
}

// -------------------------------------------------------------------

// InstanceHierarchy

// required string Name = 1;
inline bool InstanceHierarchy::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceHierarchy::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceHierarchy::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceHierarchy::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& InstanceHierarchy::name() const {
  // @@protoc_insertion_point(field_get:datamodel.InstanceHierarchy.Name)
  return name_.GetNoArena();
}
inline void InstanceHierarchy::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.InstanceHierarchy.Name)
}
#if LANG_CXX11
inline void InstanceHierarchy::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.InstanceHierarchy.Name)
}
#endif
inline void InstanceHierarchy::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.InstanceHierarchy.Name)
}
inline void InstanceHierarchy::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.InstanceHierarchy.Name)
}
inline ::std::string* InstanceHierarchy::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:datamodel.InstanceHierarchy.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstanceHierarchy::release_name() {
  // @@protoc_insertion_point(field_release:datamodel.InstanceHierarchy.Name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstanceHierarchy::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:datamodel.InstanceHierarchy.Name)
}

// optional string Version = 2;
inline bool InstanceHierarchy::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceHierarchy::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceHierarchy::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceHierarchy::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& InstanceHierarchy::version() const {
  // @@protoc_insertion_point(field_get:datamodel.InstanceHierarchy.Version)
  return version_.GetNoArena();
}
inline void InstanceHierarchy::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.InstanceHierarchy.Version)
}
#if LANG_CXX11
inline void InstanceHierarchy::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.InstanceHierarchy.Version)
}
#endif
inline void InstanceHierarchy::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.InstanceHierarchy.Version)
}
inline void InstanceHierarchy::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.InstanceHierarchy.Version)
}
inline ::std::string* InstanceHierarchy::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:datamodel.InstanceHierarchy.Version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstanceHierarchy::release_version() {
  // @@protoc_insertion_point(field_release:datamodel.InstanceHierarchy.Version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstanceHierarchy::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:datamodel.InstanceHierarchy.Version)
}

// repeated .datamodel.InternalElement InternalElement = 3;
inline int InstanceHierarchy::internalelement_size() const {
  return internalelement_.size();
}
inline void InstanceHierarchy::clear_internalelement() {
  internalelement_.Clear();
}
inline const ::datamodel::InternalElement& InstanceHierarchy::internalelement(int index) const {
  // @@protoc_insertion_point(field_get:datamodel.InstanceHierarchy.InternalElement)
  return internalelement_.Get(index);
}
inline ::datamodel::InternalElement* InstanceHierarchy::mutable_internalelement(int index) {
  // @@protoc_insertion_point(field_mutable:datamodel.InstanceHierarchy.InternalElement)
  return internalelement_.Mutable(index);
}
inline ::datamodel::InternalElement* InstanceHierarchy::add_internalelement() {
  // @@protoc_insertion_point(field_add:datamodel.InstanceHierarchy.InternalElement)
  return internalelement_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::datamodel::InternalElement >*
InstanceHierarchy::mutable_internalelement() {
  // @@protoc_insertion_point(field_mutable_list:datamodel.InstanceHierarchy.InternalElement)
  return &internalelement_;
}
inline const ::google::protobuf::RepeatedPtrField< ::datamodel::InternalElement >&
InstanceHierarchy::internalelement() const {
  // @@protoc_insertion_point(field_list:datamodel.InstanceHierarchy.InternalElement)
  return internalelement_;
}

// -------------------------------------------------------------------

// InternalElement

// required string Name = 1;
inline bool InternalElement::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalElement::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalElement::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalElement::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& InternalElement::name() const {
  // @@protoc_insertion_point(field_get:datamodel.InternalElement.Name)
  return name_.GetNoArena();
}
inline void InternalElement::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.InternalElement.Name)
}
#if LANG_CXX11
inline void InternalElement::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.InternalElement.Name)
}
#endif
inline void InternalElement::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.InternalElement.Name)
}
inline void InternalElement::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.InternalElement.Name)
}
inline ::std::string* InternalElement::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:datamodel.InternalElement.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InternalElement::release_name() {
  // @@protoc_insertion_point(field_release:datamodel.InternalElement.Name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InternalElement::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:datamodel.InternalElement.Name)
}

// optional string RefBaseSystemUnitPath = 2;
inline bool InternalElement::has_refbasesystemunitpath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalElement::set_has_refbasesystemunitpath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalElement::clear_has_refbasesystemunitpath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalElement::clear_refbasesystemunitpath() {
  refbasesystemunitpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_refbasesystemunitpath();
}
inline const ::std::string& InternalElement::refbasesystemunitpath() const {
  // @@protoc_insertion_point(field_get:datamodel.InternalElement.RefBaseSystemUnitPath)
  return refbasesystemunitpath_.GetNoArena();
}
inline void InternalElement::set_refbasesystemunitpath(const ::std::string& value) {
  set_has_refbasesystemunitpath();
  refbasesystemunitpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.InternalElement.RefBaseSystemUnitPath)
}
#if LANG_CXX11
inline void InternalElement::set_refbasesystemunitpath(::std::string&& value) {
  set_has_refbasesystemunitpath();
  refbasesystemunitpath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.InternalElement.RefBaseSystemUnitPath)
}
#endif
inline void InternalElement::set_refbasesystemunitpath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_refbasesystemunitpath();
  refbasesystemunitpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.InternalElement.RefBaseSystemUnitPath)
}
inline void InternalElement::set_refbasesystemunitpath(const char* value, size_t size) {
  set_has_refbasesystemunitpath();
  refbasesystemunitpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.InternalElement.RefBaseSystemUnitPath)
}
inline ::std::string* InternalElement::mutable_refbasesystemunitpath() {
  set_has_refbasesystemunitpath();
  // @@protoc_insertion_point(field_mutable:datamodel.InternalElement.RefBaseSystemUnitPath)
  return refbasesystemunitpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InternalElement::release_refbasesystemunitpath() {
  // @@protoc_insertion_point(field_release:datamodel.InternalElement.RefBaseSystemUnitPath)
  clear_has_refbasesystemunitpath();
  return refbasesystemunitpath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InternalElement::set_allocated_refbasesystemunitpath(::std::string* refbasesystemunitpath) {
  if (refbasesystemunitpath != NULL) {
    set_has_refbasesystemunitpath();
  } else {
    clear_has_refbasesystemunitpath();
  }
  refbasesystemunitpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), refbasesystemunitpath);
  // @@protoc_insertion_point(field_set_allocated:datamodel.InternalElement.RefBaseSystemUnitPath)
}

// optional .datamodel.SupportedRoleClass SupportedRoleClass = 3;
inline bool InternalElement::has_supportedroleclass() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InternalElement::set_has_supportedroleclass() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InternalElement::clear_has_supportedroleclass() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InternalElement::clear_supportedroleclass() {
  if (supportedroleclass_ != NULL) supportedroleclass_->::datamodel::SupportedRoleClass::Clear();
  clear_has_supportedroleclass();
}
inline const ::datamodel::SupportedRoleClass& InternalElement::supportedroleclass() const {
  const ::datamodel::SupportedRoleClass* p = supportedroleclass_;
  // @@protoc_insertion_point(field_get:datamodel.InternalElement.SupportedRoleClass)
  return p != NULL ? *p : *reinterpret_cast<const ::datamodel::SupportedRoleClass*>(
      &::datamodel::_SupportedRoleClass_default_instance_);
}
inline ::datamodel::SupportedRoleClass* InternalElement::mutable_supportedroleclass() {
  set_has_supportedroleclass();
  if (supportedroleclass_ == NULL) {
    supportedroleclass_ = new ::datamodel::SupportedRoleClass;
  }
  // @@protoc_insertion_point(field_mutable:datamodel.InternalElement.SupportedRoleClass)
  return supportedroleclass_;
}
inline ::datamodel::SupportedRoleClass* InternalElement::release_supportedroleclass() {
  // @@protoc_insertion_point(field_release:datamodel.InternalElement.SupportedRoleClass)
  clear_has_supportedroleclass();
  ::datamodel::SupportedRoleClass* temp = supportedroleclass_;
  supportedroleclass_ = NULL;
  return temp;
}
inline void InternalElement::set_allocated_supportedroleclass(::datamodel::SupportedRoleClass* supportedroleclass) {
  delete supportedroleclass_;
  supportedroleclass_ = supportedroleclass;
  if (supportedroleclass) {
    set_has_supportedroleclass();
  } else {
    clear_has_supportedroleclass();
  }
  // @@protoc_insertion_point(field_set_allocated:datamodel.InternalElement.SupportedRoleClass)
}

// repeated .datamodel.InternalElement InternalElement = 4;
inline int InternalElement::internalelement_size() const {
  return internalelement_.size();
}
inline void InternalElement::clear_internalelement() {
  internalelement_.Clear();
}
inline const ::datamodel::InternalElement& InternalElement::internalelement(int index) const {
  // @@protoc_insertion_point(field_get:datamodel.InternalElement.InternalElement)
  return internalelement_.Get(index);
}
inline ::datamodel::InternalElement* InternalElement::mutable_internalelement(int index) {
  // @@protoc_insertion_point(field_mutable:datamodel.InternalElement.InternalElement)
  return internalelement_.Mutable(index);
}
inline ::datamodel::InternalElement* InternalElement::add_internalelement() {
  // @@protoc_insertion_point(field_add:datamodel.InternalElement.InternalElement)
  return internalelement_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::datamodel::InternalElement >*
InternalElement::mutable_internalelement() {
  // @@protoc_insertion_point(field_mutable_list:datamodel.InternalElement.InternalElement)
  return &internalelement_;
}
inline const ::google::protobuf::RepeatedPtrField< ::datamodel::InternalElement >&
InternalElement::internalelement() const {
  // @@protoc_insertion_point(field_list:datamodel.InternalElement.InternalElement)
  return internalelement_;
}

// repeated .datamodel.Attribute Attribute = 5;
inline int InternalElement::attribute_size() const {
  return attribute_.size();
}
inline void InternalElement::clear_attribute() {
  attribute_.Clear();
}
inline const ::datamodel::Attribute& InternalElement::attribute(int index) const {
  // @@protoc_insertion_point(field_get:datamodel.InternalElement.Attribute)
  return attribute_.Get(index);
}
inline ::datamodel::Attribute* InternalElement::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:datamodel.InternalElement.Attribute)
  return attribute_.Mutable(index);
}
inline ::datamodel::Attribute* InternalElement::add_attribute() {
  // @@protoc_insertion_point(field_add:datamodel.InternalElement.Attribute)
  return attribute_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute >*
InternalElement::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:datamodel.InternalElement.Attribute)
  return &attribute_;
}
inline const ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute >&
InternalElement::attribute() const {
  // @@protoc_insertion_point(field_list:datamodel.InternalElement.Attribute)
  return attribute_;
}

// -------------------------------------------------------------------

// SupportedRoleClass

// required string RefRoleClassPath = 1;
inline bool SupportedRoleClass::has_refroleclasspath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SupportedRoleClass::set_has_refroleclasspath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SupportedRoleClass::clear_has_refroleclasspath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SupportedRoleClass::clear_refroleclasspath() {
  refroleclasspath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_refroleclasspath();
}
inline const ::std::string& SupportedRoleClass::refroleclasspath() const {
  // @@protoc_insertion_point(field_get:datamodel.SupportedRoleClass.RefRoleClassPath)
  return refroleclasspath_.GetNoArena();
}
inline void SupportedRoleClass::set_refroleclasspath(const ::std::string& value) {
  set_has_refroleclasspath();
  refroleclasspath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.SupportedRoleClass.RefRoleClassPath)
}
#if LANG_CXX11
inline void SupportedRoleClass::set_refroleclasspath(::std::string&& value) {
  set_has_refroleclasspath();
  refroleclasspath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.SupportedRoleClass.RefRoleClassPath)
}
#endif
inline void SupportedRoleClass::set_refroleclasspath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_refroleclasspath();
  refroleclasspath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.SupportedRoleClass.RefRoleClassPath)
}
inline void SupportedRoleClass::set_refroleclasspath(const char* value, size_t size) {
  set_has_refroleclasspath();
  refroleclasspath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.SupportedRoleClass.RefRoleClassPath)
}
inline ::std::string* SupportedRoleClass::mutable_refroleclasspath() {
  set_has_refroleclasspath();
  // @@protoc_insertion_point(field_mutable:datamodel.SupportedRoleClass.RefRoleClassPath)
  return refroleclasspath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SupportedRoleClass::release_refroleclasspath() {
  // @@protoc_insertion_point(field_release:datamodel.SupportedRoleClass.RefRoleClassPath)
  clear_has_refroleclasspath();
  return refroleclasspath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SupportedRoleClass::set_allocated_refroleclasspath(::std::string* refroleclasspath) {
  if (refroleclasspath != NULL) {
    set_has_refroleclasspath();
  } else {
    clear_has_refroleclasspath();
  }
  refroleclasspath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), refroleclasspath);
  // @@protoc_insertion_point(field_set_allocated:datamodel.SupportedRoleClass.RefRoleClassPath)
}

// -------------------------------------------------------------------

// RefSemantic

// required string CorrespondingAttributePath = 1;
inline bool RefSemantic::has_correspondingattributepath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RefSemantic::set_has_correspondingattributepath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RefSemantic::clear_has_correspondingattributepath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RefSemantic::clear_correspondingattributepath() {
  correspondingattributepath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_correspondingattributepath();
}
inline const ::std::string& RefSemantic::correspondingattributepath() const {
  // @@protoc_insertion_point(field_get:datamodel.RefSemantic.CorrespondingAttributePath)
  return correspondingattributepath_.GetNoArena();
}
inline void RefSemantic::set_correspondingattributepath(const ::std::string& value) {
  set_has_correspondingattributepath();
  correspondingattributepath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.RefSemantic.CorrespondingAttributePath)
}
#if LANG_CXX11
inline void RefSemantic::set_correspondingattributepath(::std::string&& value) {
  set_has_correspondingattributepath();
  correspondingattributepath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.RefSemantic.CorrespondingAttributePath)
}
#endif
inline void RefSemantic::set_correspondingattributepath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_correspondingattributepath();
  correspondingattributepath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.RefSemantic.CorrespondingAttributePath)
}
inline void RefSemantic::set_correspondingattributepath(const char* value, size_t size) {
  set_has_correspondingattributepath();
  correspondingattributepath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.RefSemantic.CorrespondingAttributePath)
}
inline ::std::string* RefSemantic::mutable_correspondingattributepath() {
  set_has_correspondingattributepath();
  // @@protoc_insertion_point(field_mutable:datamodel.RefSemantic.CorrespondingAttributePath)
  return correspondingattributepath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RefSemantic::release_correspondingattributepath() {
  // @@protoc_insertion_point(field_release:datamodel.RefSemantic.CorrespondingAttributePath)
  clear_has_correspondingattributepath();
  return correspondingattributepath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RefSemantic::set_allocated_correspondingattributepath(::std::string* correspondingattributepath) {
  if (correspondingattributepath != NULL) {
    set_has_correspondingattributepath();
  } else {
    clear_has_correspondingattributepath();
  }
  correspondingattributepath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), correspondingattributepath);
  // @@protoc_insertion_point(field_set_allocated:datamodel.RefSemantic.CorrespondingAttributePath)
}

// -------------------------------------------------------------------

// Attribute

// required string Name = 1;
inline bool Attribute::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attribute::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attribute::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attribute::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Attribute::name() const {
  // @@protoc_insertion_point(field_get:datamodel.Attribute.Name)
  return name_.GetNoArena();
}
inline void Attribute::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.Attribute.Name)
}
#if LANG_CXX11
inline void Attribute::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.Attribute.Name)
}
#endif
inline void Attribute::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.Attribute.Name)
}
inline void Attribute::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.Attribute.Name)
}
inline ::std::string* Attribute::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:datamodel.Attribute.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Attribute::release_name() {
  // @@protoc_insertion_point(field_release:datamodel.Attribute.Name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Attribute::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:datamodel.Attribute.Name)
}

// required string AttributeDataType = 2;
inline bool Attribute::has_attributedatatype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attribute::set_has_attributedatatype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attribute::clear_has_attributedatatype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attribute::clear_attributedatatype() {
  attributedatatype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_attributedatatype();
}
inline const ::std::string& Attribute::attributedatatype() const {
  // @@protoc_insertion_point(field_get:datamodel.Attribute.AttributeDataType)
  return attributedatatype_.GetNoArena();
}
inline void Attribute::set_attributedatatype(const ::std::string& value) {
  set_has_attributedatatype();
  attributedatatype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.Attribute.AttributeDataType)
}
#if LANG_CXX11
inline void Attribute::set_attributedatatype(::std::string&& value) {
  set_has_attributedatatype();
  attributedatatype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.Attribute.AttributeDataType)
}
#endif
inline void Attribute::set_attributedatatype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_attributedatatype();
  attributedatatype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.Attribute.AttributeDataType)
}
inline void Attribute::set_attributedatatype(const char* value, size_t size) {
  set_has_attributedatatype();
  attributedatatype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.Attribute.AttributeDataType)
}
inline ::std::string* Attribute::mutable_attributedatatype() {
  set_has_attributedatatype();
  // @@protoc_insertion_point(field_mutable:datamodel.Attribute.AttributeDataType)
  return attributedatatype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Attribute::release_attributedatatype() {
  // @@protoc_insertion_point(field_release:datamodel.Attribute.AttributeDataType)
  clear_has_attributedatatype();
  return attributedatatype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Attribute::set_allocated_attributedatatype(::std::string* attributedatatype) {
  if (attributedatatype != NULL) {
    set_has_attributedatatype();
  } else {
    clear_has_attributedatatype();
  }
  attributedatatype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attributedatatype);
  // @@protoc_insertion_point(field_set_allocated:datamodel.Attribute.AttributeDataType)
}

// optional string Value = 3;
inline bool Attribute::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Attribute::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Attribute::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Attribute::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Attribute::value() const {
  // @@protoc_insertion_point(field_get:datamodel.Attribute.Value)
  return value_.GetNoArena();
}
inline void Attribute::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:datamodel.Attribute.Value)
}
#if LANG_CXX11
inline void Attribute::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:datamodel.Attribute.Value)
}
#endif
inline void Attribute::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:datamodel.Attribute.Value)
}
inline void Attribute::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:datamodel.Attribute.Value)
}
inline ::std::string* Attribute::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:datamodel.Attribute.Value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Attribute::release_value() {
  // @@protoc_insertion_point(field_release:datamodel.Attribute.Value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Attribute::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:datamodel.Attribute.Value)
}

// optional .datamodel.RefSemantic RefSemantic = 4;
inline bool Attribute::has_refsemantic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Attribute::set_has_refsemantic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Attribute::clear_has_refsemantic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Attribute::clear_refsemantic() {
  if (refsemantic_ != NULL) refsemantic_->::datamodel::RefSemantic::Clear();
  clear_has_refsemantic();
}
inline const ::datamodel::RefSemantic& Attribute::refsemantic() const {
  const ::datamodel::RefSemantic* p = refsemantic_;
  // @@protoc_insertion_point(field_get:datamodel.Attribute.RefSemantic)
  return p != NULL ? *p : *reinterpret_cast<const ::datamodel::RefSemantic*>(
      &::datamodel::_RefSemantic_default_instance_);
}
inline ::datamodel::RefSemantic* Attribute::mutable_refsemantic() {
  set_has_refsemantic();
  if (refsemantic_ == NULL) {
    refsemantic_ = new ::datamodel::RefSemantic;
  }
  // @@protoc_insertion_point(field_mutable:datamodel.Attribute.RefSemantic)
  return refsemantic_;
}
inline ::datamodel::RefSemantic* Attribute::release_refsemantic() {
  // @@protoc_insertion_point(field_release:datamodel.Attribute.RefSemantic)
  clear_has_refsemantic();
  ::datamodel::RefSemantic* temp = refsemantic_;
  refsemantic_ = NULL;
  return temp;
}
inline void Attribute::set_allocated_refsemantic(::datamodel::RefSemantic* refsemantic) {
  delete refsemantic_;
  refsemantic_ = refsemantic;
  if (refsemantic) {
    set_has_refsemantic();
  } else {
    clear_has_refsemantic();
  }
  // @@protoc_insertion_point(field_set_allocated:datamodel.Attribute.RefSemantic)
}

// repeated .datamodel.Attribute Attribute = 5;
inline int Attribute::attribute_size() const {
  return attribute_.size();
}
inline void Attribute::clear_attribute() {
  attribute_.Clear();
}
inline const ::datamodel::Attribute& Attribute::attribute(int index) const {
  // @@protoc_insertion_point(field_get:datamodel.Attribute.Attribute)
  return attribute_.Get(index);
}
inline ::datamodel::Attribute* Attribute::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:datamodel.Attribute.Attribute)
  return attribute_.Mutable(index);
}
inline ::datamodel::Attribute* Attribute::add_attribute() {
  // @@protoc_insertion_point(field_add:datamodel.Attribute.Attribute)
  return attribute_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute >*
Attribute::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:datamodel.Attribute.Attribute)
  return &attribute_;
}
inline const ::google::protobuf::RepeatedPtrField< ::datamodel::Attribute >&
Attribute::attribute() const {
  // @@protoc_insertion_point(field_list:datamodel.Attribute.Attribute)
  return attribute_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace datamodel

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AML_2eproto__INCLUDED
